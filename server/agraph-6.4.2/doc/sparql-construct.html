<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="author" content="Franz Incorporated"/>
<title>SPARQL CONSTRUCT | AllegroGraph 6.4.2</title>
<link rel='stylesheet' href='jquery-ui.custom.min.css' />
<link rel='stylesheet' href='stylesheet.css' />
<link rel='stylesheet' href='print.css' media='print' />
<body id="sparql-construct"><div id="header"> <p>                 </p>                <p><script src="jquery.min.js" type="text/javascript" charset="utf-8"></script> <script src="jquery-ui.custom.min.js" type="text/javascript" charset="utf-8"></script> <script src="activebookmark.js" type="text/javascript" charset="utf-8"></script> </p> <div id='search-form'>   <form method="GET" action="https://www.google.com/search">     <input type="hidden" name="as_sitesearch" value=""> </input>     <input type="text" size="40" name="as_q" value="" placeholder="Please enable JavaScript to use search!"> </input>&nbsp;     <input type="submit" value="Search" disabled> </input>   </form> </div> <script>    /* Docudown has no support for function calls in HTML attributes. 
<ul>
<li>Thus, we set the as_sitesearch attribute using JavaScript below.    */   (function () { 'use strict'; var properValue = "franz.com/agraph/support/documentation/6.4.2/"; var input = document.querySelector(   '#search-form input[name="as_sitesearch"]'); input.setAttribute('value', properValue); /* The submit button was disabled so that search would be 
<ul>
<li>impossible for users without JavaScript. Enabling now: */ document.querySelector('#search-form input[type="submit"]').   removeAttribute('disabled'); document.querySelector('#search-form input[name="as_q"]').   removeAttribute('placeholder');   })(); </script> <div id="copyright">  Copyright (c) 2005 - 2018 Franz, Incorporated</div> <div id="timestamp">  Last updated 8 June 2018 at 06:55</div> <a href="https://franz.com" alt="Franz Inc Home Page"><div id="hdLogo"> </div></a> </li></ul></li></ul>        <h1>SPARQL <code>CONSTRUCT</code> in AllegroGraph</h1></div> <div id="contents">  <div id="docIndex"> <ul id="agmenu"> <li><a href="index.html">Documentation Index</a> 
<ul>
<li><a href="release-notes.html">Release Notes</a></li>
<li><a href="agraph-quick-start.html">Quick Start</a></li>
<li><a href="agraph-introduction.html" id="agraph-introduction-tab">Introduction</a></li>
<li>Setup and Configuration
<ul>
<li><a href="http://franz.com/agraph/downloads/" target="_blank">Download</a></li>
<li><a href="server-installation.html">Server Installation</a></li>
<li><a href="daemon-config.html">Server Configuration and Control</a></li>
<li><a href="agwebview.html">WebView</a></li>
<li><a href="upgrade-guide.html">Database Upgrading</a></li></ul></li>
<li>Server Management
<ul>
<li><a href="performance-tuning.html">Performance Tuning</a></li>
<li><a href="deleting-duplicate-triples.html">Deleting Duplicate Triples</a></li>
<li><a href="purging-deleted-triples.html">Purging Deleted Triples</a></li>
<li><a href="audit.html">Auditing</a></li>
<li><a href="managing-users.html">Managing Users</a></li>
<li><a href="replication.html">Replication</a></li>
<li><a href="point-in-time-recovery.html">Point-in-Time Recovery</a></li>
<li><a href="transaction-log-archiving.html">Transaction Log Archiving</a></li>
<li><a href="security-overview.html">Security Overview</a></li>
<li><a href="security.html">Security Implementation</a></li></ul></li>
<li>Tools
<ul>
<li><a href="agtool.html">agtool</a></li>
<li><a href="agload.html">Data Loading</a></li>
<li><a href="agexport.html">Data Export</a></li>
<li><a href="backup-and-restore.html">Backup and Restore</a></li>
<li><a href="agquery.html">Querying</a></li>
<li><a href="reasoner-tutorial.html" id="reasoner-tutorial-tab">RDFS++</a></li>
<li><a href="materializer.html">Materializer</a></li></ul></li>
<li>Details
<ul>
<li><a href="triple-index.html">AllegroGraph Indices</a></li>
<li><a href="text-index.html">Full-text Indices</a></li>
<li><a href="encoded-ids.html">Encoded IDs</a></li>
<li><a href="connection-pooling.html">Connection Pooling</a></li>
<li><a href="geospatial-nd.html">N-dimensional Geospatial Overview</a></li>
<li><a href="magic-properties.html#sparql-magic-geo-2d">2-D Geospatial</a></li>
<li><a href="magic-properties.html#sparql-magic-temporal">Temporal</a></li>
<li><a href="magic-properties.html#sparql-magic-sna">Social Network</a></li>
<li><a href="javascript.html">JavaScript</a></li>
<li><a href="datatypes.html">Datatypes</a></li>
<li><a href="rapper.html">Data Conversion (Rapper)</a></li>
<li><a href="stored-procedures.html">Stored Procedures</a></li>
<li><a href="triple-attributes.html">Triple Attributes</a></li></ul></li>
<li>Querying
<ul>
<li><a href="sparql-overview.html">SPARQL documentation summary</a></li>
<li><a href="sparql-reference.html">SPARQL Reference</a></li>
<li><a href="spin.html">SPIN</a></li>
<li><a href="magic-properties.html">SPARQL Magic Properties</a></li>
<li><a href="prolog-tutorial.html">Prolog</a></li></ul></li>
<li>3rd-party tools
<ul>
<li><a href="solr-index.html">Solr text Indices</a></li>
<li><a href="mongo-interface.html">MongoDB integration</a></li>
<li><a href="TBCplugin.html">TopBraid Composer Plugin</a></li>
<li><a href="agraph-introduction.html#othertools">Cloudera</a></li></ul></li>
<li>Client APIs
<ul>
<li><a href="http://franz.com/agraph/gruff/" title="Gruff" target="_blank">Gruff</a></li>
<li><a href="http-protocol.html">REST/HTTP interface</a></li>
<li><a href="http-reference.html">HTTP reference</a></li>
<li><a href="javadoc/index.html">Javadocs (Sesame and Jena)</a></li>
<li><a href="python/index.html">Python API</a></li>
<li><a href="lisp-reference.html">Lisp Reference</a></li>
<li><a href="javascript.html">JavaScript</a></li></ul></li>
<li>Tutorials
<ul>
<li><a href="geospatial-nd-tutorial.html">N-dimensional Geospatial</a></li>
<li><a href="sparql-tutorial.html">SPARQL Tutorial</a></li>
<li><a href="java-tutorial/java-tutorial.html">Java Sesame</a></li>
<li><a href="java-tutorial/jena-tutorial.html">Java Jena</a></li>
<li><a href="python/tutorial.html">Python Sesame</a></li>
<li><a href="lisp-quickstart.html">Lisp</a></li>
<li><a href="prolog-tutorial.html">Prolog</a></li>
<li><a href="tutorial-index.html">More...</a></li></ul></li>
<li>Other
<ul>
<li><a href="suggested-reading.html">Suggested Reading</a></li>
<li><a href="http://franz.com/ps/services/conferences_seminars/" title="Conferences and Seminars" target="_blank">Conferences and Seminars</a></li>
<li><a href="http://github.com/franzinc">Source Code on Github</a></li>
<li><a href="http://agraph.franz.com/cresources/index.lhtml" target="_blank">Community Resources</a></li>
<li><a href="http://franz.com/agraph/ec2/">Amazon EC2</a></li>
<li><a href="copyrights.html">Copyrights</a></li>
<li><a href="change-history.html" id="change-history-tab">Change History</a></li></ul></li>
<li><a href="http://franz.com/" target="_blank">Franz, Inc.</a> </li> </ul> </li></ul><p><script> $(function() { $( "#agmenu" ).menu(); }); </script> </p></div>   <div id="main-content"> <h1>Parts, stores, and <code>CONSTRUCT</code></h1><p><code>SELECT</code>, <code>ASK</code>, and <code>DESCRIBE</code> queries have something in common: they require access only to triple parts found in the current store. (In fact, in the case of an <code>ASK</code> query, no parts are needed; the result is a boolean.) </p><p>That is to say, no result yielded by one of these queries can refer to a resource or literal that is not mentioned in the store on which you ran the query. </p><p><code>CONSTRUCT</code>, on the other hand, can produce triples that are composed of parts not found in the triple store being queried. For example, given the dataset </p>
<pre><code>&lt;http://example.com/a&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "something" . </code></pre><p>and the query </p>
<pre><code>CONSTRUCT {  
  ?x &lt;http://example.org/hasLiteral&gt; ?literal .  
}  
WHERE {  
  ?x ?p ?literal .  
  FILTER (isLiteral(?literal))  
} </code></pre><p>the store contains three parts (two URIs and a literal), but the output features the additional resource not present in the store: <code>&lt;http://example.org/hasLiteral&gt;</code>. </p><p>What would happen if a <code>CONSTRUCT</code> query returned an AllegroGraph <code>triple</code> &#8212; that is, a compact vector containing UPI representations of parts? Everything would work, right up until you tried to fetch the value of the UPI representing <code>&lt;http://example.org/hasLiteral&gt;</code>, which isn't in the store. You'd see an error like this: </p>
<pre><code>triple-store(11): (upi-&gt;value (db.agraph::coerce-to-upi (resource "http://example.org/hasLiteral")))  
Error: The UPI #(54 20 61 123 204 203 226 83 60 128 225 0) has not been  
       added to the triple-store's string dictionary.  
  [condition type: upi-not-in-string-table-error] </code></pre><p>(Note that <em>all</em> query results will exhibit this problem if considered outside their originating store &#8212; AllegroGraph can only resolve the UPIs when the triple-store is available. <code>CONSTRUCT</code> is a different case.) </p><p>In order to produce triples that can later be examined, the query engine must intern these resources in the store being queried (the approach taken in AllegroGraph 2). This is not an ideal solution: &#8212; the store might be read-only, or a federation, and in any case the store's string table would grow over time as new queries were run against the store. </p><p>AllegroGraph has a mechanism for referring to RDF parts outside of a parent store: <code>future-part</code>s. These are Lisp objects that store an RDF value in its expanded form, and they're perfect for solving this problem. However, they don't fit into a <code>triple</code>, which is a vector of bytes, optimized for storing UPIs. For this reason, <code>CONSTRUCT</code> queries using the algebra query engine don't return triples; instead, they can return 3-element vectors containing <code>future-part</code>s and UPIs. </p><p>Similarly, blank nodes are meaningless outside of the context of a containing triple-store; furthermore, a blank node generated in one store could conceivably collide with a blank node already present in another. In programmatic <code>CONSTRUCT</code> output, blank nodes are represented by integers. </p><p>You can trivially take the output and insert it into a triple store by mapping back from integers to blank nodes. Here is an example using the Lisp API: </p>
<pre><code>(defun add-construct-output-to-store (faux-triples db &amp;key (g (default-graph-upi db)))  
  (let ((bnode-mappings (make-hash-table)))  
    (flet ((part (x)  
             (typecase x  
               (integer  
                 (or (gethash x bnode-mappings)  
                     (setf (gethash x bnode-mappings)  
                           (new-blank-node :db db))))  
               (t x))))  
      (loop for tr in faux-triples do  
            (add-triple (part (svref tr 0))  ; s  
                        (part (svref tr 1))  ; p  
                        (part (svref tr 2))  ; o  
                        :db db  
                        :g g)))))  
</code></pre></div>  <p><script> $.each($("#agmenu ul li a"), function(ignore, link) {   var anchor = $(link);   anchor.parent().on("click", function () { window.location = anchor.prop("href"); }); }); $("#agmenu").css("display", "block") </script> </p> 
</body>
</html>
