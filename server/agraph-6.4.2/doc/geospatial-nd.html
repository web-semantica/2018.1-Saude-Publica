<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="author" content="Franz Incorporated"/>
<title>N-dimensional Geospatial Facility | AllegroGraph 6.4.2</title>
<link rel='stylesheet' href='jquery-ui.custom.min.css' />
<link rel='stylesheet' href='stylesheet.css' />
<link rel='stylesheet' href='print.css' media='print' />
<body id="n-dimensional-geospatial"> <div id="header"> <p>                 </p>                <p><script src="jquery.min.js" type="text/javascript" charset="utf-8"></script> <script src="jquery-ui.custom.min.js" type="text/javascript" charset="utf-8"></script> <script src="activebookmark.js" type="text/javascript" charset="utf-8"></script> </p> <div id='search-form'>   <form method="GET" action="https://www.google.com/search">     <input type="hidden" name="as_sitesearch" value=""> </input>     <input type="text" size="40" name="as_q" value="" placeholder="Please enable JavaScript to use search!"> </input>&nbsp;     <input type="submit" value="Search" disabled> </input>   </form> </div> <script>    /* Docudown has no support for function calls in HTML attributes. 
<ul>
<li>Thus, we set the as_sitesearch attribute using JavaScript below.    */   (function () { 'use strict'; var properValue = "franz.com/agraph/support/documentation/6.4.2/"; var input = document.querySelector(   '#search-form input[name="as_sitesearch"]'); input.setAttribute('value', properValue); /* The submit button was disabled so that search would be 
<ul>
<li>impossible for users without JavaScript. Enabling now: */ document.querySelector('#search-form input[type="submit"]').   removeAttribute('disabled'); document.querySelector('#search-form input[name="as_q"]').   removeAttribute('placeholder');   })(); </script> <div id="copyright">  Copyright (c) 2005 - 2018 Franz, Incorporated</div> <div id="timestamp">  Last updated 8 June 2018 at 06:55</div> <a href="https://franz.com" alt="Franz Inc Home Page"><div id="hdLogo"> </div></a> </li></ul></li></ul>       <h1>AllegroGraph 6.4.2 N-dimensional Geospatial</h1></div> <div id="contents">  <div id="docIndex"> <ul id="agmenu"> <li><a href="index.html">Documentation Index</a> 
<ul>
<li><a href="release-notes.html">Release Notes</a></li>
<li><a href="agraph-quick-start.html">Quick Start</a></li>
<li><a href="agraph-introduction.html" id="agraph-introduction-tab">Introduction</a></li>
<li>Setup and Configuration
<ul>
<li><a href="http://franz.com/agraph/downloads/" target="_blank">Download</a></li>
<li><a href="server-installation.html">Server Installation</a></li>
<li><a href="daemon-config.html">Server Configuration and Control</a></li>
<li><a href="agwebview.html">WebView</a></li>
<li><a href="upgrade-guide.html">Database Upgrading</a></li></ul></li>
<li>Server Management
<ul>
<li><a href="performance-tuning.html">Performance Tuning</a></li>
<li><a href="deleting-duplicate-triples.html">Deleting Duplicate Triples</a></li>
<li><a href="purging-deleted-triples.html">Purging Deleted Triples</a></li>
<li><a href="audit.html">Auditing</a></li>
<li><a href="managing-users.html">Managing Users</a></li>
<li><a href="replication.html">Replication</a></li>
<li><a href="point-in-time-recovery.html">Point-in-Time Recovery</a></li>
<li><a href="transaction-log-archiving.html">Transaction Log Archiving</a></li>
<li><a href="security-overview.html">Security Overview</a></li>
<li><a href="security.html">Security Implementation</a></li></ul></li>
<li>Tools
<ul>
<li><a href="agtool.html">agtool</a></li>
<li><a href="agload.html">Data Loading</a></li>
<li><a href="agexport.html">Data Export</a></li>
<li><a href="backup-and-restore.html">Backup and Restore</a></li>
<li><a href="agquery.html">Querying</a></li>
<li><a href="reasoner-tutorial.html" id="reasoner-tutorial-tab">RDFS++</a></li>
<li><a href="materializer.html">Materializer</a></li></ul></li>
<li>Details
<ul>
<li><a href="triple-index.html">AllegroGraph Indices</a></li>
<li><a href="text-index.html">Full-text Indices</a></li>
<li><a href="encoded-ids.html">Encoded IDs</a></li>
<li><a href="connection-pooling.html">Connection Pooling</a></li>
<li><a href="geospatial-nd.html">N-dimensional Geospatial Overview</a></li>
<li><a href="magic-properties.html#sparql-magic-geo-2d">2-D Geospatial</a></li>
<li><a href="magic-properties.html#sparql-magic-temporal">Temporal</a></li>
<li><a href="magic-properties.html#sparql-magic-sna">Social Network</a></li>
<li><a href="javascript.html">JavaScript</a></li>
<li><a href="datatypes.html">Datatypes</a></li>
<li><a href="rapper.html">Data Conversion (Rapper)</a></li>
<li><a href="stored-procedures.html">Stored Procedures</a></li>
<li><a href="triple-attributes.html">Triple Attributes</a></li></ul></li>
<li>Querying
<ul>
<li><a href="sparql-overview.html">SPARQL documentation summary</a></li>
<li><a href="sparql-reference.html">SPARQL Reference</a></li>
<li><a href="spin.html">SPIN</a></li>
<li><a href="magic-properties.html">SPARQL Magic Properties</a></li>
<li><a href="prolog-tutorial.html">Prolog</a></li></ul></li>
<li>3rd-party tools
<ul>
<li><a href="solr-index.html">Solr text Indices</a></li>
<li><a href="mongo-interface.html">MongoDB integration</a></li>
<li><a href="TBCplugin.html">TopBraid Composer Plugin</a></li>
<li><a href="agraph-introduction.html#othertools">Cloudera</a></li></ul></li>
<li>Client APIs
<ul>
<li><a href="http://franz.com/agraph/gruff/" title="Gruff" target="_blank">Gruff</a></li>
<li><a href="http-protocol.html">REST/HTTP interface</a></li>
<li><a href="http-reference.html">HTTP reference</a></li>
<li><a href="javadoc/index.html">Javadocs (Sesame and Jena)</a></li>
<li><a href="python/index.html">Python API</a></li>
<li><a href="lisp-reference.html">Lisp Reference</a></li>
<li><a href="javascript.html">JavaScript</a></li></ul></li>
<li>Tutorials
<ul>
<li><a href="geospatial-nd-tutorial.html">N-dimensional Geospatial</a></li>
<li><a href="sparql-tutorial.html">SPARQL Tutorial</a></li>
<li><a href="java-tutorial/java-tutorial.html">Java Sesame</a></li>
<li><a href="java-tutorial/jena-tutorial.html">Java Jena</a></li>
<li><a href="python/tutorial.html">Python Sesame</a></li>
<li><a href="lisp-quickstart.html">Lisp</a></li>
<li><a href="prolog-tutorial.html">Prolog</a></li>
<li><a href="tutorial-index.html">More...</a></li></ul></li>
<li>Other
<ul>
<li><a href="suggested-reading.html">Suggested Reading</a></li>
<li><a href="http://franz.com/ps/services/conferences_seminars/" title="Conferences and Seminars" target="_blank">Conferences and Seminars</a></li>
<li><a href="http://github.com/franzinc">Source Code on Github</a></li>
<li><a href="http://agraph.franz.com/cresources/index.lhtml" target="_blank">Community Resources</a></li>
<li><a href="http://franz.com/agraph/ec2/">Amazon EC2</a></li>
<li><a href="copyrights.html">Copyrights</a></li>
<li><a href="change-history.html" id="change-history-tab">Change History</a></li></ul></li>
<li><a href="http://franz.com/" target="_blank">Franz, Inc.</a> </li> </ul> </li></ul><p><script> $(function() { $( "#agmenu" ).menu(); }); </script> </p></div>   
<div class='table-of-contents' id='table-of-contents'>

<ul>
<li><a href='#header2-9' title='Introduction'>Introduction</a></li>
<li><a href='#header2-15' title='Two Dimensional encoding'>Two Dimensional encoding</a></li>
<li><a href='#header2-49' title='Extension to higher dimensions'>Extension to higher dimensions</a></li>
<li><a href='#header2-65' title='Units and Ordinate Types'>Units and Ordinate Types</a>
<ul>
<li><a href='#header3-86' title='nD string formats'>nD string formats</a>
<ul>
<li><a href='#header4-88' title='The datatype has only :default or :cartesian ordinates'>The datatype has only :default or :cartesian ordinates</a></li>
<li><a href='#header4-100' title='The datatype has spherical ordinates'>The datatype has spherical ordinates</a></li></ul></li></ul></li>
<li><a href='#header2-113' title='AGWebView Datatype Designer'>AGWebView Datatype Designer</a></li>
<li><a href='#header2-119' title='nD Geospatial Automation'>nD Geospatial Automation</a></li>
<li><a href='#header2-122' title='SPARQL magic properties'>SPARQL magic properties</a></li>
<li><a href='#header2-125' title='The Lisp interface'>The Lisp interface</a></li>
<li><a href='#header2-128' title='Further reading - a call location example'>Further reading - a call location example</a></li></ul>
<div id='tocLink'><a href='index.html'>Documentation Index</a></div>
</div>
  <div id="main-content"> <p><a name="geo-intro"></a> </p><a name='header2-9' id='header2-9'></a><h2>Introduction</h2><p>AllegroGraph provides a novel mechanism for efficient storage and retrieval of multi-dimensional data, and spatial data in particular. We often refer to this kind of data as "geospatial" and will do so in this document, although that term refers specifically to positions on or around the earth's surface.  AllegroGraph supports a more general notion of N-dimensional ordinate systems that could be used in non-geo fields such as semiconductor manufacturing and biology. </p><p>This document gives an overview of the N-dimensional (nD) geospatial facility.  It is the first thing to read about nD, and prepares the reader for the <a href="geospatial-nd-tutorial.html">N-dimensional Geospatial Usage Guide</a> document, a practical tutorial which illustrates defining an nD datatype using AGWebView and making queries on sample data. </p><p>To use the geo implementation effectively one must understand the principles under which it operates. </p><p>A database administrator (DBA) should start by considering with how the data will be retrieved (queried), as only that consideration will inform how the data should best be stored. This is especially true when defining a geospatial encoding. While the usual datatype encodings such as <code>xsd:float</code> denote only a single and obvious data encoding, nD provides an essentially unbounded family of encodings, each supporting different sets of ordinates and optimized for particular kinds of searches. </p><p><a name="encoding-2d"></a> </p><a name='header2-15' id='header2-15'></a><h2>Two Dimensional encoding</h2><p>We will start the explanation using two-dimensional coordinates and then generalize to higher dimensions.  We will use spherical coordinates, i.e. latitude and longitude, but the ordinates in a nD encoding do not all need to be spatial. For example, it could make sense to define a six-dimensional encoding with latitude, longitude, altitude, data-time, pressure, and temperature.  We will use "geospatial" to refer informally even to encodings that contain no spatial ordinates. </p><p>Suppose we are interested in all data within a given radius of a certain point.  We start by examining all the data within a square bounding box and then filter out all data within that box but more distant than the radius from the specified point. </p><p><a name="figure2-1"></a> <img src="image-2d-proximity-2.png" alt="image"></img> </p><p>  <em>Figure 2-1: 2d proximity</em> </p><p>A 2-dimensional encoding will encode latitude (<em>lat</em>) and longitude (<em>lon</em>) ordinates into a single UPI (a <em>Unique Part Identifier</em>, see <a href="agraph-introduction.html#upi-def">here</a> in the <a href="agraph-introduction.html" id="agraph-introduction-tab">AllegroGraph Introduction</a>). It divides the most-significant ordinate (<em>lat</em>) into strips of a known width, with the DBA choosing the strip size to be similar to the expected dimension of a typical search region. In other words, if the DBA expects to be searching for all coordinates within a 1 kilometer bounding box, the width of the <em>lat</em> strips would be chosen as 1 kilometer.  Geospatial UPIs are then linearly sorted, first on the latitude strip, next on the entire longitude ordinate, and finally on the remainder of the latitude ordinate. </p><p><a name="figure2-2"></a> </p><p><img src="image-2d-strips.png" alt="image"></img> </p><p>  <em>Figure 2-2: 2d Strips</em> </p><p>What advantage does this provide?  Examining data with a known <em>lon</em> range within a single <em>lat</em> strip is linear and easily optimized by AllegroGraph, like any other kind of linear range query. So the geospatial UPI representation transforms an area search into a traversal of a small number of short linear ranges, and linear traversals are something computers are very efficient at doing.  The effect on performance is that retrieval speed for all data within a local region is proportional to the number of data items in the result set, and is relatively independent of the size of the whole store. </p><p>The limitation of the strip strategy of the geospatial UPI datatype is that the DBA creating the dataset must know in advance something about how the data will be queried, i.e. the typical width of regions of interest.  This is the cost of achieving near-linear-time performance with the number of data in the result set.  Fortunately, this estimate does not need to be exact. Performance is best if the strip width is similar to the bounding-box height, but degrades only gently (i.e. linearly) with the number of strips that must be examined, or similarly if the strip width is much smaller than the bounding-box width. Even an order of magnitude error will not reduce performance so severely as to make the data unusable.  (A more detailed exploration of this is below.)  If expected use covers a very large spread of ranges, then the data could also be saved multiple times with different strip widths. </p><p>There are currently three kinds of proximity search supported.  The radial proximity search, shown in Figures 2-3 through 2-6, first computes the bounding box of the circle, then determines the regions of the several strips that intersect that bounding box, and then traverses those data filtering out those outside the specified radius. </p><p>A bounding-box search works similarly, except uses a different filter that eliminates data outside the specified bounding box. </p><p>A polygon region search also first determines the bounding box of the polygon, determines the regions of strips that need to be traversed, and filters for points within the given polygon. </p><p>There are two components to the cost of a proximity search, and it is important to understand them.  One cost is associated with the amount of data that must be traversed and filtered.  This cost is proportional to the density of data within the traversed strip regions. The other cost is the overhead of establishing cursors to access and traverse each separate strip, and possibly paging those index regions of the triple store into memory. (A <em>cursor</em> is an object that allows iterating over triples that satisfy a query. See <a href="agraph-introduction.html#cursors">here</a> in <a href="agraph-introduction.html" id="agraph-introduction-tab">AllegroGraph Introduction</a> for more information.) </p><p>The magnitudes of these separate costs is hard to predict. If the data are dense -- that is, if there are a large number of data within each strip region -- then the cost of accessing the separate strips could be small compared to the cost of examining each datum. If the data are sparse -- if there are only a few data within each strip segment -- the cursor cost could dominate. It is difficult to give firm guidance about selecting strip widths. If geospatial search performance will be a critical feature of an applications, or if the database will be subject to extreme scaling pressure, it may be useful to experiment with performance benchmarks on real or synthesized data. Understanding these costs will be even more significant when higher dimensional spaces are considered. </p><p>In two dimensions, the optimum strip width will be equal to the usual diameter of a search region. In that case a search will require traversing small portions of just two strips, The ratio of the number of data points that need to be examined and filtered on radial distance will be 8/pi. See figure 2-3. </p><p><a name="figure2-3"></a> </p><p><img src="image-circle-strips-exact.png" alt="image"></img> </p><p><em>Figure 2-3: Exact circle strips</em> </p><p>If the search region is much smaller, it will often be the case that only a single strip needs be traversed.  But the proportion of data scanned to the size of the result set will be smaller, so the search is less efficient. See figure 2-4. </p><p><a name="figure2-4"></a> </p><p><img src="image-circle-strips-small.png" alt="image"></img> </p><p><em>Figure 2-4: Small circle touches only one strip</em> </p><p>If the size of the search region is large compared to the strip width, the proportion of data scanned to the size of the result set stays well behaved, approaching 4/pi, but the number of separate strip regions that must be scanned increases, harming efficiency. See figure 2-5. </p><p><a name="figure2-5"></a> </p><p><img src="image-circle-strips-large.png" alt="image"></img> </p><p><em>Figure 2-5: Larger circle spans three strips</em> </p><p>If the discrepancy is very large (see figure 2-6), the number of strips grows linearly. </p><p><a name="figure2-6"></a> </p><p><img src="image-circle-strips-very-large.png" alt="image"></img> </p><p><em>Figure 2-6: Very large circle spans six strips</em> </p><p>Nonetheless, in two dimensions the performance of proximity searches decreases gently. Suppose we have a flat area with X and Y coordinates (such as a city).  Even if the strip size for a particular geospatial ordinate is as much as an order of magnitude away from the Y range used in a particular search, in practice the strip approach is tremendously more efficient than direct X-Y search even for huge databases. If it is anticipated that data must be searched using widely different ranges at different times, then the data can be duplicated in the database using multiple datatype encodings with different strip sizes. For example, if we are storing cell phone location data, and sometimes we wanted to find cell phone location records within a 100 meter radius of a specific location, and other times we wanted to find calls within a 10 kilometer radius of that location, then it would make sense to record the data with multiple separate triples. </p><p><a name="encoding-nd"></a> </p><a name='header2-49' id='header2-49'></a><h2>Extension to higher dimensions</h2><p>The two dimensional approach extends naturally to three and higher dimensions.  Instead of organizing data into strips it is stored in 3D or higher-order prisms. </p><p>For a simple lon/lat/time proximity search, if the prism dimensions are exactly the same as the search diameter, only short segments of four prisms must be traversed.  The cylindrical region in figure 3-1 contains data within a certain central radius and within a certain time bound.  (A bounding box in three dimensions would appear as a rectangular solid in this diagram.) </p><p><a name="figure3-1"></a> <img src="image-4-prisms-725.png" alt="image"></img> </p><p><em>Figure 3-1: A bounding boxes spanning four prisms</em> </p><p>Note that instead of having to traverse just two strips as in the two-dimensional case, AllegroGraph needs to traverse four prisms. This portion of the cost -- the number of prism regions that must be traversed -- increases with a power one less than the dimensionality. Now suppose the search diameter is twice as large as the prism width (figure 3-2). </p><p><a name="figure3-2"></a> </p><p><img src="image-16-prisms-725.png" alt="image"></img> </p><p><em>Figure 3-2: A bounding boxes spanning 16 prisms</em> </p><p>The number of prisms increases with the square of the discrepancy between radius and prism width.  (A few prisms could perhaps be eliminated by clever geometric heuristics.)  The cost of underestimating an ordinate strip width (prism width) increases exponentially in the number of dimensions.  If the width had been estimated more accurately, efficiency will be less affected. </p><p><a name="figure3-3"></a> </p><p><img src="image-4-prisms-1450.png" alt="image"></img> </p><p><em>Figure 3-3: Larger bounding boxes</em> </p><p>This suggests that in higher dimension subtypes, the best strategy will be to overestimate strip widths, as this will reduce the number of prisms that must be traversed.  Again, experimentation with test data will be more reliable than theory. </p><p>The nD facility can handle higher dimensions, but diagrams are hard to draw. The algorithm has no upper limit but as implemented, all the ordinate values must be packed into 80 binary bits, so at most 80 ordinates (with one bit of data each) can be supported. The effective limit is, of course, much lower. </p><p><a name="units-and-ordinates"></a> </p><a name='header2-65' id='header2-65'></a><h2>Units and Ordinate Types</h2><p>Each nD ordinate will be one of six types, explained below: </p>
<ul>
<li>latitude</li>
<li>longitude</li>
<li>altitude</li>
<li>time</li>
<li>cartesian</li>
<li>general/other</li></ul><p>Ordinates of type latitude, longitude, and cartesian are the ones that participate in proximity queries.  A datatype with either a latitude or a longitude type ordinate must have both, and that datatype may not have any cartesian ordinates.  Spatial proximity queries (<code>inCircle</code>, <code>inBoundingBox</code>, or <code>inPolygon</code>) against such a datatype will assume haversine (spherical) distances.  If a datatype has any cartesian type ordinates, it must have at least two, and spatial queries against it will use N-dimensional cartesian distances. </p><p>All other ordinate types are compared against plain minimum/maximum bounding box limits.  A proximity query must include those minimum and maximum limits. The <em>general/other</em> type is anything not already described. The value of general/number is a number. </p><p>For most nD ordinates the ordinate value is either dimensionless or in an implicit unit known to the programmer but with which nD need not be concerned. </p><p>The latitude and longitude ordinates are the exception. They have units of degrees, but these have no intrinsic relationship with distance (compare the surface of a basketball and the surface of the earth).  If an <code>inCircle</code> query specifies a unit of km (the default) or miles, then an <code>inCircle</code> query assumes distances on the earth's surface, but for any other sphere the normal unit of distance should be the radian, which is a meaningful distance unit on the surface of a sphere regardless of the radius of that sphere. </p><p>All other typed ordinates in proximity queries are tested against the bounding box bounds in that dimension in a bounding box.  For example, if we have a 4D datatype with ordinates latitude, longitude, altitude, and time, we could make an <code>inCircle</code> query with these parameters (here ignoring the details of syntax for the different languages in which the query might be expressed): </p>
<pre><code>latitude       34.649  
longitude      -127.362  
radius         1  
units          "km"  
altitude-min   2500  
altitude-max   5000  
time-min       "2014-08-14T11:37:00Z"  
time-max       "2014-08-14T11:39:30Z"  
</code></pre><p>This describes a vertical cylinder, 1 km in radius, between 2500 and 5000 in altitude, during the given 2 minute 30 second time interval.  Each ordinate with its own bounding limits are completely independent of one another. </p><p>The type of each ordinate is specified at the time the nD datatype is defined, but for convenience ordinates named "latitude", "longitude", or "time" will automatically default to the like-named type unless a different type is specified. Default type is general/other. </p><p>On externalization, if a datatype has latitude, longitude, and optionally altitude, nD prints using <a href="http://en.wikipedia.org/wiki/ISO_6709">ISO 6709</a> format. If the datatype has a time ordinate, it is printed using <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. If there are both, the two representations are concatenated (time last), separated by a caret (`^'). These special ordinates are printed at the start of the string representation -- otherwise, all ordinates are printed in ordinate order.  Printing these special ordinates at the start of the externalized string facilitates efficient recognition on re-import. </p><p>On input the geospatial parser accepts the above special formats, or accepts all ordinates in real-number representation.  Ordinates may appear in any order -- the significance order within the encoding will always be preserved upon internalization. </p><p>All ordinates are treated as analog quantities and appear as decimal real numbers. However, they are not stored as machine floats (that would use up too many bits) but as values based on the maximum, minimum, and resolution. Therefore, values appear as approximations (generally different from what is entered). This is standard for the computer representation of floats but you may find the the difference to be greater than what you (at first) expect. After the first internalization, the externalized values should be stable, and the string representation of the nD datum should round trip. </p><p>There is no nD support for ordinates with exact integer "enum" values.  Integer enum ordinate values can be emulated with reasonable efficiency by allocating enough resolution to the ordinate to guarantee a stored value will always be significantly closer than 0.5 from the desired value, and rounding the value upon retrieval. </p><p><a name="nd-string-formats"></a> </p><a name='header3-86' id='header3-86'></a><h3>nD string formats</h3><p>In this section, we describe the nD literal string formats when nD data is ingested or externalized. Keep in mind that a literal string will be recognized and ingested as an nD literal (rather than as a string) only if an applicable datatype or predicate mapping has been established.  See <a href="lisp-reference.html#automate-nd-datatype-mappings" title="description of automate-nd-datatype-mappings">automate-nd-datatype-mappings</a>. </p><a name='header4-88' id='header4-88'></a><h4>The datatype has only :default or :cartesian ordinates</h4><p>The simplest case is an nD datatype that has only <code>:default</code> or <code>:cartesian</code> type ordinates. The externalized literal string will contain the several ordinate values in order of precedence, which is the same order in which they appear in the datatype definition. Each ordinate will start with the <code>&amp;</code> character, the name of the ordinate, an <code>=</code>, and the ordinate value as a float.  This same format is used for ingest, except that the ordinates are accepted in any order.  The letter <code>e</code> may appear as an exponent marker in the usual float syntax. </p><p>So a simple 3-dimension Cartesian x/y/z literal might be exported this way: </p>
<pre><code>"&amp;x=10.0&amp;y=-4.2e1&amp;z=3.1415911088501502" </code></pre><p>In the section <a href="geospatial-nd-tutorial.html#resolution">Why actual resolution differs from requested</a> in <a href="geospatial-nd-tutorial.html">N-dimensional Geospatial</a>, we discuss why values ingested are modified to fit in the available number of bits. This means that the encoded ordinate values only approximate the numeric values passed to the encoder.  The quantization of an ordinate value will generally be different than the lexical number from which it was initially encoded.  For example, this N-triples datum </p>
<pre><code>"&amp;x=10.0&amp;y=-4.2e1&amp;z=3.1415911088501502"^^&lt;http://franz.com/ns/allegrograph/5.0/geo/nd#_x_ca_-1.+2_+1.+2_+1.-4_+1.+0_y_ca_-1.+2_+1.+2_+1.-4_+1.+0_z_ca_-1.+2_+1.+2_+1.-4&gt; </code></pre><p>or simply </p>
<pre><code>"&amp;x=10.0&amp;y=-4.2e1&amp;z=3.1415911088501502" </code></pre><p>if the appropriate nD predicate encoding were in effect would be quantized and later externalized as </p>
<pre><code>"&amp;x=10.0&amp;y=-42.0&amp;z=3.1415889018427947" </code></pre><p>The externalize/ingest cycle is designed so that ordinate values will not wander thereafter over additional round trips, although this cannot be guaranteed in all extreme cases. </p><p>The nD quantization of lexical values into a finite number of bit representations is similar to the quantization that happens in converting lexical character representations of fractional numbers into binary floating point.  For example, tbe number 0.1 cannot be represented exactly in IEEE floating point; nor in general can it be represented in an nD ordinate encoding.  The conceptual model for nD data is that all ordinate values are "analog" approximations of real-world values, such as might be obtained from a necessarily-imprecise clock, GPS, or transducer. </p><a name='header4-100' id='header4-100'></a><h4>The datatype has spherical ordinates</h4><p>Various special-case syntaxes are supported if an nD datatype includes latitude-longitude and/or time ordinates.  These syntaxes provide some degree of human readability. </p><p>Ordinates of type <code>:latitude</code>, <code>:longitude</code>, <code>:altitude</code>, and <code>:time</code> may be treated specially.  If a datatype has a single :latitude and a single <code>:longitude</code>, and optionally a single <code>:altitude</code>, the datatype will be externalized using <a href="https://en.wikipedia.org/wiki/ISO_6709">ISO6709</a> fractional decimal syntax.  If additionally there is a single <code>:time</code> ordinate, it will be appended to this string in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format, separated by a <code>^</code> character.  This portion of the externalization will always appear at the start of the literal syntax -- this is for human readability.  Any additional <code>:default</code> ordinates will follow. </p><p>For example, this literal string mapped to an appropriate nD datatype </p>
<pre><code>"-24.2-123.4^2014-06-15T08:00:00&amp;pressure=0.9839" </code></pre><p>might be quantized and then externalized as </p>
<pre><code>"-24.20020716188222-123.40003015681543^2014-06-15T14:59:59,0027952194Z&amp;pressure=0.9838956902557977" </code></pre><p>The stored value is represented as exactly as possible (given the stored value is binary and the printed value is decimal), which is why there are so many fractional digits. The application can present the value in a more human-readable form if desired. </p><p>On input the <a href="https://en.wikipedia.org/wiki/ISO_6709">ISO6709</a> parser will recognize and accept either <code>+/-DDMMSS.F*+/-DDDMMSS.F*</code> or <code>+/-DD.F*+/-DDD.F*</code> lexical format, optionally including an <code>:altitude</code>.  The decimal point and arbitrary number of fractional digits are optional in the first syntax. </p><p>Given the appropriate nD datatype definition, all the following literal strings would read as the same nD literal: </p>
<pre><code>"+34.00-123.50^2015-07-24T08:00:00Z&amp;pressure=0.98"  
"+34.00-123.50&amp;t=2015-07-24T08:00:00Z&amp;pressure=0.98"  
"&amp;lat=34.00&amp;lon=-123.50&amp;t=2015-07-24T08:00:00Z&amp;pressure=0.98"  
"&amp;lat=34.0&amp;lon=-123.5&amp;t=2015-07-24T08:00:00+00:00&amp;pressure=0.98000"  
"&amp;pressure=0.98&amp;lon=-123.50&amp;lat=34.00&amp;t=3646713600"  
"&amp;pressure=0.98&amp;lon=-123.50&amp;lat=34.00&amp;t=3.646713600e9" </code></pre><p>If ISO syntax is used, the ISO ordinates must appear at the start of the literal string. This restriction allows faster ingest parsing because the format is determined very quickly. </p><p><a name="webview-geo"></a> </p><a name='header2-113' id='header2-113'></a><h2>AGWebView Datatype Designer</h2><p>New to the nD geospatial facility is an interactive design tool integrated into <a href="agwebview.html">WebView</a>. The designer is illustrated just below, but see <a href="geospatial-nd-tutorial.html#webview-geo">here</a> in the <a href="geospatial-nd-tutorial.html">N-dimensional Geospatial Usage Guide and Example</a> document for details. </p><p><a name="figure6-1"></a> </p><p><img src="image-InitialDesigner.png" alt="image"></img> </p><p><em>Figure 5-1: The designer in WebView</em> </p><p><a name="geo-automation"></a> </p><a name='header2-119' id='header2-119'></a><h2>nD Geospatial Automation</h2><p>New repositories have geospatial automation enabled. This means that loading a geospatial triple with its type specified will automatically install the datatype and associate the predicate of the triple with that datatype. See <a href="geospatial-nd-tutorial.html#geo-automation">nD Geospatial Automation</a> in the <a href="geospatial-nd-tutorial.html">N-dimensional Geospatial Usage Guide and Example</a> document for details. </p><p><a name="sparql-magic"></a> </p><a name='header2-122' id='header2-122'></a><h2>SPARQL magic properties</h2><p>The SPARQL magic properties for nD geospatial are listed <a href="magic-properties.html#magic-prop-list">here</a> in <a href="magic-properties.html">SPARQL Magic Properties</a>, under the heading N-dimensional Geospatial. There is a brief note about the nD geospatial magic properties <a href="magic-properties.html#sparql-magic-geo-nd">earlier in that document</a>. Note there are also 2-d geospatial magic properties. These do not apply to nD geospatial. </p><p><a name="lisp-interface"></a> </p><a name='header2-125' id='header2-125'></a><h2>The Lisp interface</h2><p>Various Lisp functions relate to nD geospatial. They are described <a href="lisp-reference.html#lisp-nd-geospatial-reference">here in the Lisp Reference</a>. </p><p><a name="example-run-through"></a> </p><a name='header2-128' id='header2-128'></a><h2>Further reading - a call location example</h2><p>The <a href="geospatial-nd-tutorial.html">N-dimensional Geospatial Usage Guide</a> tutorial provides a practical example using the nD facility in AllegroGraph. </p></div> </div>  <p><script> $.each($("#agmenu ul li a"), function(ignore, link) {   var anchor = $(link);   anchor.parent().on("click", function () { window.location = anchor.prop("href"); }); }); $("#agmenu").css("display", "block") </script> </p> 
</body>
</html>
